// DO NOT EDIT! This file was auto-generated by crates/build/re_types_builder/src/codegen/cpp/mod.rs
// Based on "crates/store/re_sdk_types/definitions/rerun/archetypes/gaussiansplats3d.fbs".

#pragma once

#include "../collection.hpp"
#include "../component_batch.hpp"
#include "../component_column.hpp"
#include "../components/color.hpp"
#include "../components/half_size3d.hpp"
#include "../components/opacity.hpp"
#include "../components/rotation_quat.hpp"
#include "../components/translation3d.hpp"
#include "../result.hpp"

#include <cstdint>
#include <optional>
#include <utility>
#include <vector>

namespace rerun::archetypes {
    /// **Archetype**: A batch of 3D Gaussian splats.
    ///
    /// Each splat is an anisotropic 3D Gaussian defined by a center position, three
    /// per-axis scale values (standard deviations), a rotation quaternion, a base
    /// opacity, and a color.
    ///
    /// At render time the 3D covariance matrix is reconstructed as
    /// `Σ = R · diag(s²) · Rᵀ`, projected into screen space via the EWA splatting
    /// formulation, and drawn as an alpha-blended quad whose transparency follows the
    /// resulting 2D Gaussian distribution.
    ///
    /// If your source data stores scales in log-space (common in 3DGS training),
    /// apply `exp()` before logging.  If opacity is stored in logit-space, apply
    /// `sigmoid()` before logging.
    struct GaussianSplats3D {
        /// Per-splat 3D center position in object (local) space.
        std::optional<ComponentBatch> centers;

        /// Per-splat anisotropic scale (standard deviation) along each of the three
        /// local axes, in **linear space**.
        ///
        /// These correspond directly to the diagonal of the scale matrix
        /// `S = diag(sx, sy, sz)` used when reconstructing the 3D covariance:
        /// `Σ = R · S² · Rᵀ`.
        ///
        /// If your training framework outputs log-scales, apply `exp()` before logging.
        std::optional<ComponentBatch> scales;

        /// Per-splat rotation as a unit quaternion in `(x, y, z, w)` convention.
        ///
        /// Defines the orientation of the splat's local frame relative to the object
        /// frame.  If omitted, all splats are axis-aligned (identity rotation).
        std::optional<ComponentBatch> quaternions;

        /// Per-splat base opacity in the range [0, 1].
        ///
        /// This is the peak alpha at the Gaussian center before the spatial falloff is
        /// applied.  It represents a learned physical property of the splat and is
        /// independent of the color alpha channel.
        ///
        /// If your source data stores opacity in logit-space (as is common during
        /// 3DGS training), apply `sigmoid()` before logging.
        ///
        /// Defaults to `1.0` if not specified.
        std::optional<ComponentBatch> opacities;

        /// Per-splat color in linear RGBA.
        ///
        /// The RGB channels define the base color of the Gaussian.  The alpha channel,
        /// if present, acts as an additional visualization-level transparency multiplier
        /// applied on top of `opacities`.
        ///
        /// Defaults to white `(1, 1, 1, 1)` if not specified.
        std::optional<ComponentBatch> colors;

      public:
        /// The name of the archetype as used in `ComponentDescriptor`s.
        static constexpr const char ArchetypeName[] = "rerun.archetypes.GaussianSplats3D";

        /// `ComponentDescriptor` for the `centers` field.
        static constexpr auto Descriptor_centers = ComponentDescriptor(
            ArchetypeName, "GaussianSplats3D:centers",
            Loggable<rerun::components::Translation3D>::ComponentType
        );
        /// `ComponentDescriptor` for the `scales` field.
        static constexpr auto Descriptor_scales = ComponentDescriptor(
            ArchetypeName, "GaussianSplats3D:scales",
            Loggable<rerun::components::HalfSize3D>::ComponentType
        );
        /// `ComponentDescriptor` for the `quaternions` field.
        static constexpr auto Descriptor_quaternions = ComponentDescriptor(
            ArchetypeName, "GaussianSplats3D:quaternions",
            Loggable<rerun::components::RotationQuat>::ComponentType
        );
        /// `ComponentDescriptor` for the `opacities` field.
        static constexpr auto Descriptor_opacities = ComponentDescriptor(
            ArchetypeName, "GaussianSplats3D:opacities",
            Loggable<rerun::components::Opacity>::ComponentType
        );
        /// `ComponentDescriptor` for the `colors` field.
        static constexpr auto Descriptor_colors = ComponentDescriptor(
            ArchetypeName, "GaussianSplats3D:colors",
            Loggable<rerun::components::Color>::ComponentType
        );

      public:
        GaussianSplats3D() = default;
        GaussianSplats3D(GaussianSplats3D&& other) = default;
        GaussianSplats3D(const GaussianSplats3D& other) = default;
        GaussianSplats3D& operator=(const GaussianSplats3D& other) = default;
        GaussianSplats3D& operator=(GaussianSplats3D&& other) = default;

        explicit GaussianSplats3D(
            Collection<rerun::components::Translation3D> _centers,
            Collection<rerun::components::HalfSize3D> _scales
        )
            : centers(ComponentBatch::from_loggable(std::move(_centers), Descriptor_centers)
                          .value_or_throw()),
              scales(ComponentBatch::from_loggable(std::move(_scales), Descriptor_scales)
                         .value_or_throw()) {}

        /// Update only some specific fields of a `GaussianSplats3D`.
        static GaussianSplats3D update_fields() {
            return GaussianSplats3D();
        }

        /// Clear all the fields of a `GaussianSplats3D`.
        static GaussianSplats3D clear_fields();

        /// Per-splat 3D center position in object (local) space.
        GaussianSplats3D with_centers(const Collection<rerun::components::Translation3D>& _centers
        ) && {
            centers = ComponentBatch::from_loggable(_centers, Descriptor_centers).value_or_throw();
            return std::move(*this);
        }

        /// Per-splat anisotropic scale (standard deviation) along each of the three
        /// local axes, in **linear space**.
        ///
        /// These correspond directly to the diagonal of the scale matrix
        /// `S = diag(sx, sy, sz)` used when reconstructing the 3D covariance:
        /// `Σ = R · S² · Rᵀ`.
        ///
        /// If your training framework outputs log-scales, apply `exp()` before logging.
        GaussianSplats3D with_scales(const Collection<rerun::components::HalfSize3D>& _scales) && {
            scales = ComponentBatch::from_loggable(_scales, Descriptor_scales).value_or_throw();
            return std::move(*this);
        }

        /// Per-splat rotation as a unit quaternion in `(x, y, z, w)` convention.
        ///
        /// Defines the orientation of the splat's local frame relative to the object
        /// frame.  If omitted, all splats are axis-aligned (identity rotation).
        GaussianSplats3D with_quaternions(
            const Collection<rerun::components::RotationQuat>& _quaternions
        ) && {
            quaternions = ComponentBatch::from_loggable(_quaternions, Descriptor_quaternions)
                              .value_or_throw();
            return std::move(*this);
        }

        /// Per-splat base opacity in the range [0, 1].
        ///
        /// This is the peak alpha at the Gaussian center before the spatial falloff is
        /// applied.  It represents a learned physical property of the splat and is
        /// independent of the color alpha channel.
        ///
        /// If your source data stores opacity in logit-space (as is common during
        /// 3DGS training), apply `sigmoid()` before logging.
        ///
        /// Defaults to `1.0` if not specified.
        GaussianSplats3D with_opacities(const Collection<rerun::components::Opacity>& _opacities
        ) && {
            opacities =
                ComponentBatch::from_loggable(_opacities, Descriptor_opacities).value_or_throw();
            return std::move(*this);
        }

        /// Per-splat color in linear RGBA.
        ///
        /// The RGB channels define the base color of the Gaussian.  The alpha channel,
        /// if present, acts as an additional visualization-level transparency multiplier
        /// applied on top of `opacities`.
        ///
        /// Defaults to white `(1, 1, 1, 1)` if not specified.
        GaussianSplats3D with_colors(const Collection<rerun::components::Color>& _colors) && {
            colors = ComponentBatch::from_loggable(_colors, Descriptor_colors).value_or_throw();
            return std::move(*this);
        }

        /// Partitions the component data into multiple sub-batches.
        ///
        /// Specifically, this transforms the existing `ComponentBatch` data into `ComponentColumn`s
        /// instead, via `ComponentBatch::partitioned`.
        ///
        /// This makes it possible to use `RecordingStream::send_columns` to send columnar data directly into Rerun.
        ///
        /// The specified `lengths` must sum to the total length of the component batch.
        Collection<ComponentColumn> columns(const Collection<uint32_t>& lengths_);

        /// Partitions the component data into unit-length sub-batches.
        ///
        /// This is semantically similar to calling `columns` with `std::vector<uint32_t>(n, 1)`,
        /// where `n` is automatically guessed.
        Collection<ComponentColumn> columns();
    };

} // namespace rerun::archetypes

namespace rerun {
    /// \private
    template <typename T>
    struct AsComponents;

    /// \private
    template <>
    struct AsComponents<archetypes::GaussianSplats3D> {
        /// Serialize all set component batches.
        static Result<Collection<ComponentBatch>> as_batches(
            const archetypes::GaussianSplats3D& archetype
        );
    };
} // namespace rerun
